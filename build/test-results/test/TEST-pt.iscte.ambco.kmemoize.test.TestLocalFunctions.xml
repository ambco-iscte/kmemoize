<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="pt.iscte.ambco.kmemoize.test.TestLocalFunctions" tests="4" skipped="0" failures="0" errors="0" timestamp="2026-02-02T19:10:01.819Z" hostname="LAPTOP-AMBCO" time="1.478">
  <properties/>
  <testcase name="testTwoParametersSupertypeAny()" classname="pt.iscte.ambco.kmemoize.test.TestLocalFunctions" time="0.433"/>
  <testcase name="testOneParameter()" classname="pt.iscte.ambco.kmemoize.test.TestLocalFunctions" time="0.339"/>
  <testcase name="testTwoParametersCommonSupertype()" classname="pt.iscte.ambco.kmemoize.test.TestLocalFunctions" time="0.388"/>
  <testcase name="testTwoParametersSameType()" classname="pt.iscte.ambco.kmemoize.test.TestLocalFunctions" time="0.315"/>
  <system-out><![CDATA[w: // MODULE: <main>
// FILE: Kotlin.kt
// path: C:/Users/ASUS/AppData/Local/Temp/Kotlin-Compilation15238085692008161279/sources/Kotlin.kt

fun contains(list: List<Int>, element: Int): Boolean {
  local fun foo(lst: List<Int>, e: Int): Boolean {
    return lst.contains(element = e)
  }

  return foo(lst = list, e = element)
}

fun containsMemoized(list: List<Int>, element: Int): Boolean {
  @Memoize
  local fun fooMemoized(lst: List<Int>, e: Int): Boolean {
    when {
      #fooMemoized149134249Memory.containsKey(key = listOf<Any>(elements = [lst, e])).not() -> { // BLOCK
        #fooMemoized149134249Memory.put(key = listOf<Any>(elements = [lst, e]), value = lst.contains(element = e))
      }
    }
    return CHECK_NOT_NULL<Boolean>(arg0 = #fooMemoized149134249Memory.get(key = listOf<Any>(elements = [lst, e])))
  }

  return fooMemoized(lst = list, e = element)
}

private /* static final field */ val fooMemoized149134249Memory: MutableMap<List<Any>, Boolean> = mutableMapOf<List<Any>, Boolean>()
// FILE: Memoize.kt
// path: C:/Users/ASUS/AppData/Local/Temp/Kotlin-Compilation15238085692008161279/sources/Memoize.kt
package pt.iscte.ambco.kmemoize.api

@Retention(value = AnnotationRetention.RUNTIME)
@Target(allowedTargets = [AnnotationTarget.FUNCTION])
open annotation class Memoize : Annotation {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  /* fake */ override operator fun equals(other: Any?): Boolean

  /* fake */ override fun hashCode(): Int

  /* fake */ override fun toString(): String

}

@Retention(value = AnnotationRetention.RUNTIME)
@Target(allowedTargets = [AnnotationTarget.FUNCTION])
@RequiresOptIn(message = "Forcibly memoizing impure functions may lead to unintended behaviour.")
open annotation class UnsafeMemoize : Annotation {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  /* fake */ override operator fun equals(other: Any?): Boolean

  /* fake */ override fun hashCode(): Int

  /* fake */ override fun toString(): String

}


w: // MODULE: <main>
// FILE: Kotlin.kt
// path: C:/Users/ASUS/AppData/Local/Temp/Kotlin-Compilation3421646713662146832/sources/Kotlin.kt

fun factorial(n: Int): Long {
  local fun foo(m: Int): Long {
    return when {
      EQEQ(arg0 = m, arg1 = 0) -> 1L
      else -> m.times(other = foo(m = m.minus(other = 1)))
    }
  }

  return foo(m = n)
}

fun factorialMemoized(n: Int): Long {
  @Memoize
  local fun fooMemoized(m: Int): Long {
    when {
      #fooMemoized1840095070Memory.containsKey(key = m).not() -> { // BLOCK
        #fooMemoized1840095070Memory.put(key = m, value = when {
          EQEQ(arg0 = m, arg1 = 0) -> 1L
          else -> m.times(other = fooMemoized(m = m.minus(other = 1)))
        })
      }
    }
    return CHECK_NOT_NULL<Long>(arg0 = #fooMemoized1840095070Memory.get(key = m))
  }

  return fooMemoized(m = n)
}

private /* static final field */ val fooMemoized1840095070Memory: MutableMap<Int, Long> = mutableMapOf<Int, Long>()
// FILE: Memoize.kt
// path: C:/Users/ASUS/AppData/Local/Temp/Kotlin-Compilation3421646713662146832/sources/Memoize.kt
package pt.iscte.ambco.kmemoize.api

@Retention(value = AnnotationRetention.RUNTIME)
@Target(allowedTargets = [AnnotationTarget.FUNCTION])
open annotation class Memoize : Annotation {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  /* fake */ override operator fun equals(other: Any?): Boolean

  /* fake */ override fun hashCode(): Int

  /* fake */ override fun toString(): String

}

@Retention(value = AnnotationRetention.RUNTIME)
@Target(allowedTargets = [AnnotationTarget.FUNCTION])
@RequiresOptIn(message = "Forcibly memoizing impure functions may lead to unintended behaviour.")
open annotation class UnsafeMemoize : Annotation {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  /* fake */ override operator fun equals(other: Any?): Boolean

  /* fake */ override fun hashCode(): Int

  /* fake */ override fun toString(): String

}


w: // MODULE: <main>
// FILE: Kotlin.kt
// path: C:/Users/ASUS/AppData/Local/Temp/Kotlin-Compilation12883637627644893962/sources/Kotlin.kt

fun product(a: Int, b: Double): Double {
  local fun foo(p: Int, q: Double): Double {
    return p.times(other = q)
  }

  return foo(p = a, q = b)
}

fun productMemoized(a: Int, b: Double): Double {
  @Memoize
  local fun fooMemoized(p: Int, q: Double): Double {
    when {
      #fooMemoized1204629994Memory.containsKey(key = listOf<Number>(elements = [p, q])).not() -> { // BLOCK
        #fooMemoized1204629994Memory.put(key = listOf<Number>(elements = [p, q]), value = p.times(other = q))
      }
    }
    return CHECK_NOT_NULL<Double>(arg0 = #fooMemoized1204629994Memory.get(key = listOf<Number>(elements = [p, q])))
  }

  return fooMemoized(p = a, q = b)
}

private /* static final field */ val fooMemoized1204629994Memory: MutableMap<List<Number>, Double> = mutableMapOf<List<Number>, Double>()
// FILE: Memoize.kt
// path: C:/Users/ASUS/AppData/Local/Temp/Kotlin-Compilation12883637627644893962/sources/Memoize.kt
package pt.iscte.ambco.kmemoize.api

@Retention(value = AnnotationRetention.RUNTIME)
@Target(allowedTargets = [AnnotationTarget.FUNCTION])
open annotation class Memoize : Annotation {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  /* fake */ override operator fun equals(other: Any?): Boolean

  /* fake */ override fun hashCode(): Int

  /* fake */ override fun toString(): String

}

@Retention(value = AnnotationRetention.RUNTIME)
@Target(allowedTargets = [AnnotationTarget.FUNCTION])
@RequiresOptIn(message = "Forcibly memoizing impure functions may lead to unintended behaviour.")
open annotation class UnsafeMemoize : Annotation {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  /* fake */ override operator fun equals(other: Any?): Boolean

  /* fake */ override fun hashCode(): Int

  /* fake */ override fun toString(): String

}


w: // MODULE: <main>
// FILE: Kotlin.kt
// path: C:/Users/ASUS/AppData/Local/Temp/Kotlin-Compilation12852596385620753652/sources/Kotlin.kt

fun product(a: Int, b: Int): Int {
  local fun foo(p: Int, q: Int): Int {
    return p.times(other = q)
  }

  return foo(p = a, q = b)
}

fun productMemoized(a: Int, b: Int): Int {
  @Memoize
  local fun fooMemoized(p: Int, q: Int): Int {
    when {
      #fooMemoized1305685237Memory.containsKey(key = listOf<Int>(elements = [p, q])).not() -> { // BLOCK
        #fooMemoized1305685237Memory.put(key = listOf<Int>(elements = [p, q]), value = p.times(other = q))
      }
    }
    return CHECK_NOT_NULL<Int>(arg0 = #fooMemoized1305685237Memory.get(key = listOf<Int>(elements = [p, q])))
  }

  return fooMemoized(p = a, q = b)
}

private /* static final field */ val fooMemoized1305685237Memory: MutableMap<List<Int>, Int> = mutableMapOf<List<Int>, Int>()
// FILE: Memoize.kt
// path: C:/Users/ASUS/AppData/Local/Temp/Kotlin-Compilation12852596385620753652/sources/Memoize.kt
package pt.iscte.ambco.kmemoize.api

@Retention(value = AnnotationRetention.RUNTIME)
@Target(allowedTargets = [AnnotationTarget.FUNCTION])
open annotation class Memoize : Annotation {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  /* fake */ override operator fun equals(other: Any?): Boolean

  /* fake */ override fun hashCode(): Int

  /* fake */ override fun toString(): String

}

@Retention(value = AnnotationRetention.RUNTIME)
@Target(allowedTargets = [AnnotationTarget.FUNCTION])
@RequiresOptIn(message = "Forcibly memoizing impure functions may lead to unintended behaviour.")
open annotation class UnsafeMemoize : Annotation {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

  /* fake */ override operator fun equals(other: Any?): Boolean

  /* fake */ override fun hashCode(): Int

  /* fake */ override fun toString(): String

}


]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>
